#include<stdio.h>
#include<stdlib.h>
#define max(a, b) ((a) > (b) ? (a) : (b))
/*A < (A,B) < B，那么换个角度说，只要右侧的比A小或相等的在B右边即可；同理，左侧比B大或相等的一定在A左边。
不妨以B为枚举的对象，根据B寻找符合条件的A
由于有关区间最大值，考虑用单调栈：
    首先，对于B创建一个后缀最大值单调栈（因为该栈内产生的是按后缀区间排列的最大值，便于寻找比B大的前一个数），那么根据前面的推理，A必然会落在B和大于B的前一个元素之间，这样才能保证(A,B)最长且均<B
接下去，就是要找A。
方法一：由于要A<(A,B)，所以可以用一个后缀最小值单调栈来寻找（因为后缀最小值栈内的就是依此按照后缀区间排列的后缀最小值），A就取上述B产生的区间内的后缀最小值即可。（由于是有序的，所以可以用二分查找得到索引>B的前一个元素的最小索引值）
tips：方法一的优势在于其构造的两个单调栈都是正向的，可以边读取边处理。
方法二：同B的处理，反向遍历构建A的后缀最小值栈，取A、B对应的合法区间的重叠部分
*/
//存值
int H[100005];
//存的是索引的stack
//注意！！！这里的栈指针是指向下一个的
int Bx[100005],An[100005];
int ix,in;
//二分查找 
int Search()	{
	int l=0,r=in-1;
    /*注意特殊情况，当前栈内没有元素时：
    An若空，那么while会直接结束，正确；Bx若空，那么就相当于An无索引区间限制，可以直接取最前面的，等价于Bx的栈顶元素索引设为-1，即始终小于任意的索引值
    */
    int bx_top_index =(ix==0 ? -1 : Bx[ix-1]);
	while(l<=r){
		int mid=(l+r)/2;
		if(An[mid]>bx_top_index) r=mid-1;
		else l=mid+1;
	}
	return l;//最终结果An[l]>bx_top
}

int main(){
    int N;
    scanf("%d",&N);
    int ans=0;
    //边读取边以刚读取的作为B进行枚举
    for(int i=0;i<N;i++){
        scanf("%d",&H[i]);
        while(ix&&H[i]>H[Bx[ix-1]]) ix--;//因为端点不能与内部的相同，所以这里不能有等号，否则若从新加入的那个开始算区间，有可能会导致覆盖的这个也一起被区间包含进去，从而不合题意
        while(in&&H[i]<=H[An[in-1]]) in--;//恰恰相反的是，这里必须要有等号，因为不能与内部相同意味这如果相同，要用新加入的更靠右侧的那个，来覆盖掉前面的，否则可能会取到前面的那个
        int index=Search();
        if(index!=in) ans=max(ans,i-An[index]+1);
        Bx[ix++]=i;
        An[in++]=i;
    }
    printf("%d",ans);
    return 0;
}