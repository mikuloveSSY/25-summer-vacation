#include<stdio.h>
#include<stdlib.h>

//暴力方法就是递归，每种情况记一次，但是开销太大
//数学方法是找规律，自己递推或者使用卡特兰数
//反正没有要求输出具体情况，因此可以试着直接dp算情况个数
/*每个进入的元素，要么入栈，要么直接输出；栈内则是要么不变，要么直接输出
所以这里有输入序列与输出序列两个数据，靠这两个就能确定唯一的情况，不妨用输入序列作为维护的一维
*/
int dp[20][20]={0};//第一个代表轮到的进入的数字，第二个代表栈内元素个数（或者说是栈的情况），存储的则是让栈达到该元素个数的方法数
int main(){
    int n;
    scanf("%d",&n);
    dp[0][0]=1;//初始化
    for(int i=1;i<=n+1;i++){
        for(int j=n+1;j>=1;j--){
/*该转移方程含义：
首先，默认先处理完前面轮次留下的栈的出栈，再入栈当前数字（而当前数字进入后的后续出栈，则相应的留给后续的那轮次处理）
因此，若要得到n个元素的结果，就要处理到第n+1次（因为第n个元素入栈后的出栈是由第n+1次来处理的），所以这里的循环边界也要设为n+1 
对于当前栈，若要使得栈内元素的数量为j，则可由前面轮次的栈内的数量为j-1到n+1的得到，即dp[i][j]=sum(dp[i-1][n+1]~dp[i-1][j-1])=dp[i][j+1]+dp[i-1][j-1]
*/
            dp[i][j]=dp[i][j+1]+dp[i-1][j-1];
            // printf("%d ",dp[i][j]);
        }
        // printf("\n");
    }
    //因为第n+1个元素只有入栈操作，对方案数无影响，因此对于dp[n]余留下的全部执行出栈操作，得到的总方案数就=sum(dp[n][1]~dp[n][n])=dp[n+1][1]
    printf("%d",dp[n+1][1]);
    return 0;
}

/*小tips:
对于dp[i][1]，不难发现，由于dp[i-1][0]=0，所以其方案数与dp[i][2]相等，这是合理的
因为前面轮次最少也必定会留下刚刚入栈的那个元素，所以栈内至少会有1个元素，所以dp[i-1][0]=0，相应的，dp[i][1]与dp[i][2]相比，也就只是多一个元素出栈的区别
*/